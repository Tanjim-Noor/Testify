"""Utilities shared across the comprehensive test suite."""
from __future__ import annotations

from datetime import datetime, timedelta, timezone
from typing import Iterable, List, Sequence
from uuid import uuid4

from sqlalchemy.orm import Session

from src.models.exam import Exam
from src.models.exam_question import ExamQuestion
from src.models.question import Question
from src.models.student_exam import ExamStatus, StudentExam
from src.models.user import User, UserRole
from src.utils.auth import get_password_hash

DEFAULT_TEST_PASSWORD = "StrongPass123!"


def create_test_user(db: Session, role: str = "admin", email: str | None = None, password: str = DEFAULT_TEST_PASSWORD) -> User:
    """Persist and return a user with the desired role for tests."""

    user = User(
        email=email or f"{role}_{uuid4().hex}@example.com",
        password_hash=get_password_hash(password),
        role=UserRole(role.lower()),
    )
    db.add(user)
    db.commit()
    db.refresh(user)
    return user


def _default_objective_payload(qtype: str) -> tuple[List[str], List[str]]:
    if qtype == "multi_choice":
        return ["Option A", "Option B", "Option C"], ["Option A", "Option C"]
    return ["Option A", "Option B"], ["Option B"]


def create_test_question(
    db: Session,
    qtype: str = "single_choice",
    title: str | None = None,
    options: Sequence[str] | None = None,
    correct_answers: Sequence[str] | None = None,
    max_score: int = 2,
) -> Question:
    """Insert and return a question tailored to the requested type."""

    opts, answers = _default_objective_payload(qtype)
    question = Question(
        title=title or f"Sample {qtype} question",
        description="Autogenerated fixture question",
        complexity="easy",
        type=qtype,
        options=list(options or opts) if qtype in {"single_choice", "multi_choice"} else None,
        correct_answers=list(correct_answers or (answers if qtype in {"single_choice", "multi_choice"} else [])),
        max_score=max_score,
        tags=["sample", qtype],
    )
    db.add(question)
    db.commit()
    db.refresh(question)
    return question


def create_test_exam(
    db: Session,
    admin_id,
    questions: Iterable[Question] | None = None,
    is_published: bool = False,
    duration_minutes: int = 60,
) -> Exam:
    """Create an exam along with optional question assignments."""

    now = datetime.now(timezone.utc)
    exam = Exam(
        title="Sample Exam",
        description="Autogenerated exam",
        start_time=now - timedelta(minutes=5),
        end_time=now + timedelta(hours=2),
        duration_minutes=duration_minutes,
        is_published=is_published,
        created_by=admin_id,
    )
    db.add(exam)
    db.commit()
    db.refresh(exam)

    if questions:
        for index, question in enumerate(questions):
            assignment = ExamQuestion(exam_id=exam.id, question_id=question.id, order_index=index)
            db.add(assignment)
        db.commit()
        db.refresh(exam)

    return exam


def create_test_student_exam(
    db: Session,
    exam_id,
    student_id,
    status: ExamStatus = ExamStatus.IN_PROGRESS,
    started_at: datetime | None = None,
) -> StudentExam:
    """Create a StudentExam row for the supplied exam/student pair."""

    student_exam = StudentExam(
        exam_id=exam_id,
        student_id=student_id,
        status=status,
        started_at=started_at or datetime.now(timezone.utc) - timedelta(minutes=1),
    )
    db.add(student_exam)
    db.commit()
    db.refresh(student_exam)
    return student_exam


def get_auth_headers(token: str) -> dict[str, str]:
    """Return FastAPI-ready Authorization headers."""

    return {"Authorization": f"Bearer {token}"}
